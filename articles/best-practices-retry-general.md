<properties
   pageTitle="Instructions générales fournies pour de nouvelles | Microsoft Azure"
   description="Conseils sur les nouvelles tentatives de traitement des erreurs transitoires."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="retry-general-guidance"></a>Réessayer conseils généraux

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="overview"></a>Vue d’ensemble

Toutes les applications de communiquer avec les ressources et les services à distance doivent être sensibles aux défaillances temporaires. C’est particulièrement le cas pour les applications qui s’exécutent dans le cloud, où la nature de l’environnement et de la connectivité via Internet signifie que ces types d’erreurs sont susceptibles d’être rencontrées plus souvent. Défaillances temporaires incluent la momentanément la connectivité réseau pour des composants et des services, l’indisponibilité provisoire d’un service, ou des délais d’expiration qui se produisent lorsqu’un service est occupé (e). Ces erreurs sont souvent correction automatique, et si l’action est répétée après un délai approprié, il est probablement réussir.

Ce document traite des instructions générales pour la gestion de pannes transitoires. Pour plus d’informations sur la gestion des défaillances temporaires lors de l’utilisation de services Microsoft Azure, voir [Azure spécifiques au service Réessayer les instructions](best-practices-retry-service-specific.md).

## <a name="why-do-transient-faults-occur-in-the-cloud"></a>Pourquoi les défaillances temporaires se trouvent dans le cloud ?

Erreurs transitoires peuvent se produire dans n’importe quel environnement, toute plate-forme ou un système d’exploitation et tout type d’application. Dans les solutions que s’exécutent sur local, infrastructure en local, les performances et disponibilité de l’application et ses composants est généralement conservée via redondance matérielle coûteux et souvent sous- et composants et les ressources sont situés près de chacune un autre. Ce champ est une défaillance rarement, il peut entraîner toujours défaillances temporaires - et même une panne par le biais inattendues litiges alimentation externe ou problèmes réseau ou d’autres scénarios d’urgence.

L’hébergement cloud, y compris les systèmes de cloud privé, peut proposer une plus grande disponibilité globale à l’aide de ressources partagées, redondance, basculement automatique et répartition des ressources dynamiques au sein d’un grand nombre de nœuds de cluster marchandise. Toutefois, la nature de ces environnements pouvez signifie que défaillances temporaires sont susceptibles de se produire. Il existe plusieurs raisons à cela :

* Nombre de ressources dans un environnement cloud est partagée et accès à ces ressources sont couvertes la limitation afin de protéger la ressource. Certains services refuse les connexions lorsque la charge augmente à un niveau spécifique, ou un débit maximal est atteint, afin d’autoriser le traitement des demandes existantes et pour maintenir des performances du service pour tous les utilisateurs. Cette limitation permet de maintenir la qualité de service pour voisin et d’autres clients à l’aide de la ressource partagée.
* Les environnements de cloud sont créées à l’aide de très grand nombre d’unités matérielles marchandise. Ils des performances par dynamiquement répartir la charge de plusieurs unités informatiques et les composants de l’infrastructure et fournir la fiabilité en recyclage automatiquement ou en remplaçant unités défectueuses. Cette nature dynamique signifie que les erreurs transitoires et des échecs de connexion temporaires peuvent éventuellement apparaître.
* Il existe souvent plusieurs composants matériels, notamment infrastructure réseau tels que routeurs et équilibrage de charge entre l’application et les ressources et services qu’il utilise. Cette infrastructure supplémentaire peut parfois introduire latence de connexion supplémentaires et des erreurs de connexion transitoires.
* Conditions de réseau entre le client et le serveur peuvent être variable, en particulier lors de la communication coupe Internet. Même dans les emplacements en local, trafic très important peut ralentir la communication et entraîner des erreurs de connexion intermittents.

## <a name="challenges"></a>Défis
Défaillances temporaires peuvent avoir un grand impact sur la disponibilité perçue d’une application, même si elle a été minutieusement testé dans toutes les circonstances prévisibles. Pour garantir que les applications hébergées sur le cloud fonctionnent correctement, ils doivent pouvoir y répondre aux problèmes suivants :

* L’application doit être en mesure de détecter les erreurs quand ils se produisent et déterminent si ces erreurs sont susceptibles d’être transitoires, plus longue ou défaillances Terminal Server. Différentes ressources sont susceptibles de renvoyer des réponses différentes lorsqu’une erreur se produit, et ces réponses peuvent également varier selon le contexte de l’opération ; par exemple, la réponse à une erreur lors de la lecture à partir du stockage peut-être différer de réponse à un message d’erreur lors de l’écriture de stockage. Nombre de ressources et de services ont des contrats habituelles défaillance temporaire. Toutefois, si ces informations ne sont pas disponibles, il peut être difficile à découvrir la nature de l’erreur et s’il est susceptible d’être transitoires.
* L’application doit être en mesure de recommencer l’opération si elle détermine que l’erreur est susceptible d’être transitoires et de suivre le nombre de tentatives de l’opération.
* L’application doit utiliser une stratégie appropriée pour les tentatives. Cette stratégie spécifie le nombre de tentatives, le délai entre chaque tentative et les actions à prendre après un échec. Le nombre de tentatives et le délai entre chacun d’eux approprié est souvent difficile à déterminer et varier selon le type de ressource, ainsi que les conditions d’exploitation en cours de la ressource et de l’application proprement dite.

## <a name="general-guidelines"></a>Instructions générales
Les instructions suivantes vous aideront à concevoir une défaillance transitoire appropriée transmettant mécanisme pour vos applications :

* **Déterminer s’il existe un mécanisme intégrée de relance :**
  * De nombreux services fournissent une bibliothèque SDK ou d’un client qui contient une défaillance transitoire mécanisme de gestion des. La stratégie de nouvelles tentatives qu’il utilise est généralement adaptée à la nature et la configuration requise du service cible. Vous pouvez également reste interfaces de services peuvent retourner des informations qui sont utiles pour déterminer si une nouvelle tentative est approprié et le délai d’attente avant la prochaine tentative.
  * Utiliser le mécanisme de relance intégrée où est disponible, sauf si vous avez des besoins spécifiques et bien compris qui ont qu'un comportement différent réessayer est plus approprié.
* **Déterminer si l’opération est adaptée à une nouvelle tentative**:
  * Vous devez uniquement réessayer opérations où les erreurs sont transitoires (généralement indiquées par la nature de l’erreur) et s’il existe au moins une probabilité que l’opération réussit lorsque retenté. Il est inutile de nouvelle tentative d’opérations qui indiquent une opération non valide, par exemple une base de données mise à jour d’un élément qui n’existe pas, ou les demandes à un service ou d’une ressource qui a subi une erreur critique
  * En règle générale, vous devez implémenter tentatives que si l’impact de ce total peut être déterminé, et si les conditions sont bien comprises et peuvent être validées. Dans le cas contraire, laissez-le au code pour mettre en œuvre des nouvelles tentatives d’appel. N’oubliez pas que les erreurs renvoyées à partir des ressources et services à l’extérieur de votre contrôle peuvent évoluer au fil du temps et vous devrez revenir sur votre logique de détection de défaillance transitoires.
  * Lorsque vous créez des services ou des composants, envisagez d’implémentation des codes d’erreur et les messages qui aideront les clients à déterminer si elles doivent réessayer échecs d’opérations. En particulier, indiquent si le client doit recommencez l’opération (par exemple en renvoyant une valeur **isTransient** ) et proposer un délai avant la prochaine tentative approprié. Si vous créez un service web, envisagez de retourner des erreurs personnalisées définis dans les contrats de service. Bien que les clients génériques peuvent ne pas être en mesure de lire ces documents, ils seront utiles lors de la création de clients personnalisés.
* **Déterminer un nombre de tentatives appropriée et l’intervalle :**
  * Il est essentiel d’optimiser le nombre de tentatives et l’intervalle au type de cas d’utilisation. Si vous ne pas réessayez un certain nombre de fois, l’application ne pourra pas terminer l’opération et réside en cas de panne. Si vous réessayez trop souvent, ou avec tente de trop court un intervalle entre, l’application peut contenir potentiellement de ressources telles que les threads, les connexions et la mémoire pour les périodes de temps, qui aura incidence sur le fonctionnement de l’application.
  * Les valeurs appropriées pour l’intervalle de temps et le nombre de nouvelles tentatives dépendent du type d’opération tentée. Par exemple, si l’opération fait partie d’une interaction de l’utilisateur, l’intervalle doit être courte et uniquement quelques tentatives pour éviter des utilisateurs attendre une réponse (qui contient les connexions ouvertes et peuvent réduire la disponibilité d’autres utilisateurs). Si l’opération fait partie d’un flux de travail longue en cours d’exécution ou critique, où l’annulation et redémarrer le processus sont coûteux ou beaucoup de temps, il est judicieux de Patientez un moment entre les tentatives et réessayer de plusieurs fois.
  * Déterminer les intervalles entre les tentatives appropriées est la partie la plus difficile de la conception d’une stratégie de réussie. Stratégies classiques utilisent les types d’intervalle suivants :
      * **Fonction exponentielle recul**. L’application attend quelques instants avant la première nouvelle tentative et puis augmentation exponentielle heures entre chaque tentatives suivantes. Il peut par exemple, recommencez l’opération après 3 secondes, 12 secondes, 30 secondes et ainsi de suite.
      * **Intervalles incrémentielles**. L’application attend quelques instants avant la première nouvelle tentative et puis incrémentiel heures entre chaque tentatives suivantes. Il peut par exemple, recommencez l’opération après 3 secondes, 7 secondes, 13 secondes et ainsi de suite.
      * **Intervalles réguliers**. L’application attend pour la même période de temps entre chaque tentative. Il peut par exemple, recommencez l’opération toutes les 3 secondes.
      * **Réessayez d’exécution**. Parfois une erreur transitoire est très courte, peut-être dû à un événement comme un conflit de paquets réseau ou un pic dans un composant matériel. Dans ce cas, une nouvelle tentative de l’opération immédiatement est appropriée, car il peut réussir si l’erreur a disparu dans le temps que nécessaire à l’application assembler et envoyez la demande suivante. Toutefois, il doit être jamais plusieurs tentative immédiatement et vous devez utiliser stratégies de remplacement, comme par exemple recul exponentielle ou les actions de secours, si elle immédiate échoue.
      * **Traitement aléatoire**. Un de la nouvelle tentative stratégies répertoriés ci-dessus peut inclure un sélection aléatoire pour éviter que plusieurs instances du client qui envoie les tentatives suivantes en même temps. Par exemple, une instance recommencez l’opération après 3 secondes, 11 secondes, 28 secondes et ainsi de suite pendant une autre instance recommencez l’opération après 4 secondes, 12 secondes, secondes 26, et ainsi de suite. Traitement aléatoire est une technique utile qui peut-être être combinée avec d’autres stratégies.  
  * En règle générale, utilisez une stratégie recul exponentielle pour les opérations d’arrière-plan et stratégies de nouvelle tentative immédiate ou régulières intervalle d’opérations interactives. Dans les deux cas, vous devez choisir le délai et le nombre de tentatives afin que la latence maximale pour toutes les nouvelles tentatives est comprise dans la spécification de latence de bout en bout requis.
  * Tenir compte de la combinaison de tous les facteurs qui contribuent à la valeur maximale globale pour une opération de nouvelle tentative. Ces facteurs incluent le temps nécessaire pour un échec de la connexion afin d’obtenir une réponse (généralement définie par une valeur du délai d’attente dans le client) ainsi que le délai entre les nouvelles tentatives et le nombre maximal de nouvelles tentatives. Le total de ces permanence peut entraîner très grande opération globale des heures, particulièrement quand à l’aide d’une stratégie de délai exponentielle dans laquelle l’intervalle entre les nouvelles tentatives s’accroît rapidement après chaque défaillance. Si un processus doit répondre à un service spécifique accord niveau (), la durée d’opération globale, y compris les délais d’expiration et les retards, doit être dans cet définis dans le contrat SLA
  * Stratégies de nouvelles tentatives over-AGGRESSIVE, qui ont des intervalles trop courts ou trop peuvent tentatives, peuvent avoir un effet négatif sur la ressource cible ou un service. Cela peut empêcher la ressource ou un service de récupération à partir de son état surchargée, et il va continuer à bloquer ou refuser des demandes. En outre réduire ce se traduit par un cercle vicieux où demandes plus sont envoyées à la ressource ou service et par conséquent sa capacité à récupérer.
  * Prendre en compte le délai d’expiration des opérations lorsque vous choisissez les intervalles afin d’éviter le lancement d’une nouvelle tentative immédiatement (par exemple, si le délai d’expiration est similaire à l’intervalle de tentative). Envisagez également si vous voulez conserver la total période possible (le délai d’expiration plus les intervalles) pour en dessous d’une durée totale spécifique. Opérations qui ont des délais d’expiration inhabituelle courte ou longue peuvent influencer la durée à attendre et comment souvent recommencez l’opération.
  * Utiliser le type de l’exception et les données qu’il contient, ou les codes d’erreur et les messages retournés par le service, afin d’optimiser l’intervalle et le nombre de tentatives. Pour exemple, quelques exceptions ou codes d’erreur (telles que le protocole HTTP code 503 Service non disponible avec un en-tête après réessayer dans la réponse) peuvent indiquer combien de temps peut durer l’erreur, ou que le service a échoué et ne répond pas à toute tentative ultérieure.
* **Évitez les motifs**:
  * Dans la plupart des cas, vous devez éviter mises en œuvre comprenant des couches dupliqués de code de réessayer. Évitez les designs qui incluent mécanismes réessayer en cascade, ou qui implémenter recommencer à chaque étape d’une opération qui implique une hiérarchie de requêtes, sauf si vous avez des besoins spécifiques qui exigent ceci. Dans ces circonstances exceptionnelles, utilisez les stratégies éviter des numéros excessives de nouvelles tentatives et des périodes de retard et assurez-vous que vous savez les conséquences. Par exemple, si un composant effectue une demande à l’autre, qui accède aux puis le service cible et vous implémentez réessayer avec un compte de trois sur les deux appels sera neuf réessayer tente au total sur le service. De nombreux services et ressources implémentent un mécanisme de relance intégrée et vous devez examiner comment vous pouvez désactiver ou modifier cette option si vous avez besoin mettre en œuvre des nouvelles tentatives à un niveau supérieur.
  *  Ne jamais implémenter un mécanisme de nouvelles tentatives illimitées. Ceci est susceptible d’empêcher la ressource ou le service de récupération à partir de surcharge situations et entraîner la limitation et connexions pour continuer pendant une longue période refusées. Utilisez un nombre fini ou tentatives, ou mise en œuvre d’un modèle comme [séparateur de Circuit](http://msdn.microsoft.com/library/dn589784.aspx) pour autoriser le service à récupérer.
  * Ne jamais effectuer une nouvelle tentative immédiate plusieurs fois.
  * Évitez d’utiliser un intervalle régulier, en particulier lorsque vous avez un grand nombre de nouvelles tentatives, lorsque vous accédez à des services et des ressources dans Azure. L’approche optimale est que ce scénario est une stratégie recul exponentielle avec une fonctionnalité circuit minute.
  * Empêcher plusieurs instances du même client ou plusieurs instances de clients différents, d’envoyer des nouvelles tentatives au même moment. Si c’est susceptible de se produire, présentez aléatoire dans les intervalles.
* **Tester votre stratégie de nouvelles tentatives et la mise en œuvre :**
  * Vérifiez que vous testez entièrement votre implémentation de stratégie réessayer sous en tant que large un ensemble de circonstances que possible, particulièrement quand à la fois l’application et les ressources cibles ou les services qu’il utilise sont situées sous charge extrême. Pour vérifier le comportement pendant le test, vous pouvez :
      * Injection erreurs transitoires et non transitoires au service. Par exemple, envoyer des demandes non valides ou ajouter du code qui détecte les demandes de test et répond avec différents types d’erreurs. Pour obtenir un exemple avec TestApi, voir [Défaillance Injection réalisés avec TestApi](http://msdn.microsoft.com/magazine/ff898404.aspx) et [présentation TestApi – partie 5 : Managed Code défaillance Injection API](http://blogs.msdn.com/b/ivo_manolov/archive/2009/11/25/9928447.aspx).
      * Créer un fictifs de la ressource ou un service qui retourne une plage des messages d’erreur que le service réel peut renvoyer. Assurez-vous de garde de tous les types d’erreur votre stratégie de nouvelles tentatives est conçu pour détecter.
      * Forcer erreurs transitoires se produise par temporairement la désactivation ou la surcharge du service s’il s’agit d’un service personnalisé que vous avez créé et déployé (vous doit tenter pas, bien entendu, toutes les ressources partagées de surcharge ou des services dans Azure partagés).
      * Pour les API HTTP, vous pouvez utiliser la bibliothèque FiddlerCore dans vos tests automatisés pour modifier le résultat des demandes HTTP, en ajoutant des heures supplémentaires aller-retour ou en modifiant la réponse (par exemple, le code d’état HTTP, en-têtes, corps ou d’autres facteurs). Ceci permet de tester déterministe d’un sous-ensemble des conditions échec, si transitoires défauts ou autres types de panne. Pour plus d’informations, voir [FiddlerCore](http://www.telerik.com/fiddler/fiddlercore). Pour obtenir des exemples d’utilisation de la bibliothèque, notamment la classe **HttpMangler** , examinez le [code source pour le Kit de développement de stockage Azure](https://github.com/Azure/azure-storage-net/tree/master/Test).
      * Effectuer le facteur de charge élevée et les essais simultanées pour vous assurer que le mécanisme de nouvelle tentative et stratégie fonctionne correctement dans ces conditions et non un effet négatif sur le fonctionnement du client ou entraîner une contamination croisée entre les demandes.
* **Gérer les configurations de stratégie de nouvelles tentatives :**
  * Une _stratégie de réessayer_ est une combinaison de tous les éléments de votre stratégie de réessayer. Il définit le mécanisme de détection qui détermine si une erreur est susceptible d’être transitoires, le type d’intervalle à utiliser (par exemple, standard, exponentielle recul et aléatoire), la valeur (s) intervalle réel et le nombre de fois pour recommencer.
  * Nouvelles tentatives doivent être implémentées situés à divers emplacements de l’application de la plus simple et dans chaque couche d’applications plus complexes. Plutôt que de manière irréversible les éléments de chaque stratégie à plusieurs emplacements, envisagez d’utiliser un point central pour le stockage de toutes les stratégies. Par exemple, stocker les valeurs telles que l’intervalle de tentatives dans les fichiers de configuration d’application, les lire en cours d’exécution et par programme développer les stratégies de réessayer. Cela facilite pour gérer les paramètres et de modifier et affiner les valeurs afin de répondre à l’évolution des impératifs et les scénarios. Cependant, concevoir le système pour stocker les valeurs plutôt que de relire une configuration chaque heure du fichier et vérifiez que les valeurs par défaut appropriés sont utilisés si les valeurs ne peut pas être obtenus à partir de configuration.
  * Dans une application Azure Cloud Services, pensez à stocker les valeurs qui sont utilisées pour créer les stratégies de nouvelles tentatives en cours d’exécution dans le fichier de configuration de service afin qu’ils peuvent être modifiés sans avoir besoin de redémarrer l’application.
  * Tirer parti des prédéfinis ou par défaut des stratégies de nouvelles tentatives disponibles dans le client API que vous utilisez, mais uniquement lorsqu’elles sont adaptées à votre situation. Ces stratégies sont généralement à usage général. Dans certains scénarios, ils peuvent être tout ce qui est requis, mais dans d’autres scénarios, ils peuvent peut-être pas proposer la gamme complète d’options pour l’adapter à vos besoins spécifiques. Vous devez comprendre comment les paramètres affectent votre application de test pour déterminer les valeurs qui conviennent.
* **Ouvrez une session et suivre des erreurs transitoires et non transitoires :**
  * Dans le cadre de votre stratégie de nouvelles tentatives, inclure des exceptions et autres instrumentation qui ouvre une session lorsque des nouvelles tentatives sont effectuées. Si une défaillance temporaire occasionnel et réessayer sont à prévoir et n’indiquent pas un problème, normal croissant de numéros et de nouvelles tentatives est souvent un indicateur d’un problème qui peut entraîner une défaillance ou est actuellement ayant un impact sur les performances des applications et disponibilité.
  * Ouvrez une session défaillances temporaires comme entrées avertissement plutôt que des entrées d’erreur afin que les systèmes de surveillance ne pas les détectent comme des erreurs d’application qui peuvent déclencher des alertes false.
  * Pensez à stocker une valeur dans vos entrées de journal qui indique si les tentatives ont été provoquées par la limitation dans le service, ou d’autres types d’erreurs telles que les échecs de connexion de sorte que vous pouvez les différencier lors de l’analyse des données. Augmente le nombre d’erreurs limitation est souvent un indicateur de défaut de conception dans l’application ou qu’il soit nécessaire pour basculer vers un service premium qui offre matériel dédié.  
  * Pensez à mesure et journalisation la durée globale pour les opérations qui incluent un mécanisme de réessayer. Il s’agit d’un bon indicateur de l’effet global de défaillances temporaires sur les temps de réponse utilisateur, latence des processus et l’efficacité des exemples d’utilisation de l’application. Également journal le nombre de tentatives s’est produite afin de comprendre les facteurs impliquées dans le temps de réponse.
  * Envisagez de mise en œuvre d’un télémétrie et surveillance système qui peut déclencher des alertes lorsque le numéro et taux d’échecs, le nombre moyen de tentatives ou augmente les heures globales consacrés aux opérations aboutisse, de.
* **Gérer les opérations continuellement échouent :**
  * Il y ait circonstances où l’opération continue à échouer à chaque tentative, et il est essentiel à prendre en considération la manière dont vous allez gérer cette situation :
      * Bien qu’une stratégie de nouvelles tentatives définit le nombre maximal de fois qu’une opération doit être retentée, il n’empêche pas l’application répéter l’opération à nouveau, avec le même nombre de tentatives. Par exemple, si un service de traitement des commandes échoue avec une erreur irrécupérable définitivement la place se déconnecter de l’action, la stratégie de nouvelles tentatives peut détecter un délai de connexion et prendre en compte qu’il s’agit d’une défaillance temporaire. Le code sera recommencez l’opération un certain nombre de fois, puis abandonner. Cependant, lorsqu’un autre client place une commande, l’opération tente à nouveau - même s’il est qu’Échec chaque fois.
      * Pour empêcher les tentatives en continu pour les opérations échouent en permanence, envisagez d’implémenter le [séparateur de Circuit motif](http://msdn.microsoft.com/library/dn589784.aspx). Dans ce modèle, si le nombre d’échecs dans une fenêtre de temps spécifié est supérieur au seuil, demandes sont retournés à l’appelant immédiatement comme des erreurs, sans tenter d’accéder à la ressource a échoué ou le service.
      * L’application peut tester régulièrement le service, de façon intermittente et avec très longs intervalles entre les demandes, à détecter lorsqu’il est disponible. Un intervalle approprié dépend du scénario, telles que la priorité de l’opération et la nature du service et peut être rien entre quelques minutes et quelques heures. À l’endroit où le test a réussi, l’application peut reprendre une activité normale et transmettre les requêtes au service que vous venez récupéré.
      * En attendant, il est possible de revenir à une autre instance du service (par exemple dans un centre de données différent ou une application), utilisez un service similaire qui offre des fonctionnalités (peut-être plus simple) compatible ou effectuer des opérations de remplacement dans l’espoir que le service ne sera bientôt plus disponible. Par exemple, il peut être utile stocker les demandes de service dans une file d’attente ou magasin de données et les relire plus tard. Sinon, vous pourrez peut-être rediriger l’utilisateur vers une autre instance de l’application, affecter les performances de l’application, mais toujours offrent des fonctionnalités acceptable, ou simplement retour un message à l’utilisateur indiquant que l’application n’est pas disponible à présenter.

* **Autres considérations**
  * Lorsque vous choisissez les valeurs pour le nombre de tentatives et les intervalles d’une stratégie, vous pouvez si l’opération sur le service ou la ressource fait partie d’une opération longue ou plusieurs étapes. Il peut être difficile ou coûteux à compense perte de toutes les autres procédures opérationnelles qui ont déjà réussi lorsqu’une échoue. Dans ce cas, un intervalle de très long et un grand nombre de tentatives peuvent être acceptables dans la mesure où elle ne bloque pas d’autres opérations en attente ou verrouillage ressources rares.
  * Vous pouvez si le même tentative peut entraîner des incohérences dans les données. Si certaines parties d’un processus en plusieurs étapes sont répétées et les opérations ne sont pas idempotent, il peut entraîner une incohérence. Par exemple, une opération qui incrémente une valeur si répétés, produira un résultat non valide. Répéter une opération qui envoie un message à une file d’attente peut entraîner une incohérence dans le consommateur message si elle ne peut pas détecter les messages en double. Pour éviter ce problème, assurez-vous que vous concevez chaque étape comme une opération idempotent. Pour plus d’informations sur idempotence, reportez-vous [Aux modèles idempotence](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/).
  * Examinez l’étendue des opérations qui sera retentée. Par exemple, il peut être plus facile d’implémenter un code de réessayer à un niveau qui comprend plusieurs opérations, puis recommencez tous les cas de panne. Toutefois, cela peut entraîner une idempotence problèmes ou des opérations d’annulation inutiles.
  * Si vous choisissez une étendue de nouvelles tentatives qui comprend plusieurs opérations, prendre en compte la latence de l’ensemble d’eux pour déterminer les intervalles, lors de l’analyse de la durée et de déclencher des alertes pour des échecs de total.
  * Réfléchissez comment votre stratégie de nouvelles tentatives peut affecter voisin et autres clients dans une application partagée ou lors de l’utilisation de services et ressources partagées. Stratégies de réessayer agressif peuvent entraîner un nombre croissant de défaillances temporaires se produire pour les autres utilisateurs et les applications qui partagent les ressources et services. De même, votre application peut être affectée par les stratégies de réessayer implémentées par d’autres utilisateurs des ressources et des services. Pour les applications critiques, vous pouvez décider d’utiliser les services premium qui ne sont pas partagées. Cela vous offre davantage de contrôle sur le chargement et la limitation à la suite de ces ressources et services, ce qui peuvent vous aider à justifier le coût supplémentaire.

## <a name="more-information"></a>Plus d’informations

* [Instructions de réessayer spécifiques au service Azure](best-practices-retry-service-specific.md)
* [Le bloc d’Application de gestion des erreurs transitoires](http://msdn.microsoft.com/library/hh680934.aspx)
* [Modèle circuit séparateur](http://msdn.microsoft.com/library/dn589784.aspx)
* [Compensateurs motif Transaction](http://msdn.microsoft.com/library/dn589804.aspx)
* [Modèles idempotence](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/)
